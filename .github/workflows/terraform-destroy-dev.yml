name: Destroy Dev Environment

on:
  workflow_dispatch:
    inputs:
      force_unlock_id:
        description: 'Optional: Terraform lock ID to force-unlock before destroy'
        required: false
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  terraform-destroy:
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: infrastructure/environments/dev
        run: terraform init -input=false

      - name: Force-unlock Terraform state (optional)
        if: ${{ inputs.force_unlock_id != '' }}
        working-directory: infrastructure/environments/dev
        run: terraform force-unlock -force "${{ inputs.force_unlock_id }}" || true

      - name: Discover S3 bucket and project name (by resource tags)
        id: discovery
        run: |
          set -e
          found_bucket=""
          project=""
          # Find S3 bucket tagged as dev frontend and capture project tag
          for b in $(aws s3api list-buckets --query 'Buckets[].Name' --output text); do
            tags_json=$(aws s3api get-bucket-tagging --bucket "$b" --output json 2>/dev/null || echo '{}')
            env_tag=$(echo "$tags_json" | jq -r '.TagSet[]? | select(.Key=="Environment") | .Value' | head -n1)
            name_tag=$(echo "$tags_json" | jq -r '.TagSet[]? | select(.Key=="Name") | .Value' | head -n1)
            proj_tag=$(echo "$tags_json" | jq -r '.TagSet[]? | select(.Key=="Project") | .Value' | head -n1)
            if [ "$env_tag" = "dev" ] && [ -n "$proj_tag" ] && [ "$name_tag" = "${proj_tag}-dev-frontend" ]; then
              found_bucket="$b"
              project="$proj_tag"
              break
            fi
          done
          if [ -z "$found_bucket" ]; then
            echo "No tagged dev frontend bucket found; attempting pattern match..." >&2
            for b in $(aws s3api list-buckets --query 'Buckets[].Name' --output text); do
              case "$b" in
                *-dev-frontend)
                  tags_json=$(aws s3api get-bucket-tagging --bucket "$b" --output json 2>/dev/null || echo '{}')
                  proj_tag=$(echo "$tags_json" | jq -r '.TagSet[]? | select(.Key=="Project") | .Value' | head -n1)
                  project="${proj_tag:-cicd}"
                  found_bucket="$b"
                  break
                  ;;
              esac
            done
          fi
          if [ -n "$found_bucket" ]; then
            echo "bucket=$found_bucket" >> $GITHUB_OUTPUT
          fi
          if [ -n "$project" ]; then
            echo "project_name=$project" >> $GITHUB_OUTPUT
          fi

      - name: Derive ECR repo names
        id: ecr_names
        run: |
          project="${{ steps.discovery.outputs.project_name }}"
          backend_repo=""
          frontend_repo=""
          if [ -n "$project" ]; then
            backend_repo="${project}-dev-backend"
            frontend_repo="${project}-dev-frontend"
          fi
          # Fallback: discover by name pattern if project not found
          if [ -z "$backend_repo" ] || [ -z "$frontend_repo" ]; then
            repos=$(aws ecr describe-repositories --query 'repositories[].repositoryName' --output text || true)
            for r in $repos; do
              case "$r" in
                *-dev-backend) backend_repo="$r" ;;
                *-dev-frontend) frontend_repo="$r" ;;
              esac
            done
          fi
          echo "backend_repo=$backend_repo" >> $GITHUB_OUTPUT
          echo "frontend_repo=$frontend_repo" >> $GITHUB_OUTPUT

      - name: Empty S3 bucket (required for deletion)
        run: |
          bucket="${{ steps.discovery.outputs.bucket }}"
          echo "Emptying S3 bucket: $bucket"
          versioning_status=$(aws s3api get-bucket-versioning --bucket "$bucket" --query 'Status' --output text 2>/dev/null || true)
          if [ "$versioning_status" = "Enabled" ] || [ "$versioning_status" = "Suspended" ]; then
            echo "Bucket has versioning ($versioning_status). Deleting all versions and delete markers..."
            aws s3api list-object-versions --bucket "$bucket" --output json \
              | jq -c '.Versions[]? | {Key, VersionId}' \
              | while read -r obj; do
                  key=$(echo "$obj" | jq -r .Key)
                  vid=$(echo "$obj" | jq -r .VersionId)
                  aws s3api delete-object --bucket "$bucket" --key "$key" --version-id "$vid" || true
                done
            aws s3api list-object-versions --bucket "$bucket" --output json \
              | jq -c '.DeleteMarkers[]? | {Key, VersionId}' \
              | while read -r obj; do
                  key=$(echo "$obj" | jq -r .Key)
                  vid=$(echo "$obj" | jq -r .VersionId)
                  aws s3api delete-object --bucket "$bucket" --key "$key" --version-id "$vid" || true
                done
          else
            echo "Bucket not versioned. Removing recursively..."
            aws s3 rm "s3://$bucket" --recursive || true
          fi

      - name: Delete all images from ECR repos
        run: |
          set -e
          for repo in "${{ steps.ecr_names.outputs.backend_repo }}" "${{ steps.ecr_names.outputs.frontend_repo }}"; do
            echo "Purging all images in ECR repo: $repo"
            # Loop until no images remain (handles pagination, tagged and untagged)
            while true; do
              images_json=$(aws ecr list-images --repository-name "$repo" --filter tagStatus=ANY --output json --no-paginate || echo '{}')
              count=$(echo "$images_json" | jq '.imageIds | length' 2>/dev/null || echo 0)
              if [ "$count" -eq 0 ]; then
                echo "Repository $repo is empty."
                break
              fi
              echo "Deleting $count images from $repo..."
              echo "$images_json" | jq -c '.imageIds[]' | while read -r img; do
                digest=$(echo "$img" | jq -r '.imageDigest // empty')
                tag=$(echo "$img" | jq -r '.imageTag // empty')
                if [ -n "$digest" ] && [ -n "$tag" ]; then
                  aws ecr batch-delete-image --repository-name "$repo" --image-ids imageDigest="$digest",imageTag="$tag" || true
                elif [ -n "$digest" ]; then
                  aws ecr batch-delete-image --repository-name "$repo" --image-ids imageDigest="$digest" || true
                elif [ -n "$tag" ]; then
                  aws ecr batch-delete-image --repository-name "$repo" --image-ids imageTag="$tag" || true
                fi
              done
              # Short pause to allow registry to reflect deletions
              sleep 2
            done
          done

      - name: Wait a moment for eventual consistency
        run: sleep 5

      - name: Terraform Destroy ECS module (release ALB/ENIs/SG deps)
        working-directory: infrastructure/environments/dev
        env:
          TF_VAR_mysql_password: "placeholder"
          TF_VAR_image_tag: "latest"
        run: terraform destroy -auto-approve -input=false -lock=false -lock-timeout=10m -target=module.ecs

      - name: Disable and delete CloudFront distribution explicitly
        run: |
          set -e
          project="${{ steps.discovery.outputs.project_name }}"
          bucket="${{ steps.discovery.outputs.bucket }}"
          dist_id=""
          items_json=$(aws cloudfront list-distributions --output json || echo '{}')
          echo "$items_json" | jq -e '.DistributionList.Items' >/dev/null 2>&1 || { echo "No CloudFront distributions found."; exit 0; }
          for row in $(echo "$items_json" | jq -c '.DistributionList.Items[]'); do
            id=$(echo "$row" | jq -r '.Id')
            arn=$(echo "$row" | jq -r '.ARN // empty')
            if [ -z "$arn" ]; then
              arn=$(aws cloudfront get-distribution --id "$id" --output json | jq -r '.Distribution.ARN')
            fi
            # Try match by Name tag
            if [ -n "$project" ]; then
              tags_json=$(aws cloudfront list-tags-for-resource --resource "$arn" --output json 2>/dev/null || echo '{}')
              name_tag=$(echo "$tags_json" | jq -r '.Tags.Items[]? | select(.Key=="Name") | .Value' | head -n1)
              if [ "$name_tag" = "${project}-cdn" ]; then
                dist_id="$id"
                break
              fi
            fi
            # Fallback: match by origin domain referencing bucket
            if [ -n "$bucket" ]; then
              has_origin=$(echo "$row" | jq --arg b "$bucket" -r '.Origins.Items[]? | select(.DomainName | contains($b)) | .DomainName' | head -n1)
              if [ -n "$has_origin" ]; then
                dist_id="$id"
                break
              fi
            fi
          done
          if [ -z "$dist_id" ]; then
            echo "No matching CloudFront distribution found. Continuing..."
            exit 0
          fi
          echo "Found CloudFront distribution: $dist_id"
          # Fetch config and ETag
          etag=$(aws cloudfront get-distribution-config --id "$dist_id" --query 'ETag' --output text)
          cfg=$(aws cloudfront get-distribution-config --id "$dist_id" --output json | jq '.DistributionConfig')
          enabled=$(echo "$cfg" | jq -r '.Enabled')
          if [ "$enabled" != "false" ]; then
            echo "Disabling distribution $dist_id"
            new_cfg=$(echo "$cfg" | jq '.Enabled=false')
            echo "$new_cfg" > cf-config.json
            aws cloudfront update-distribution --id "$dist_id" --if-match "$etag" --distribution-config file://cf-config.json >/dev/null
            # Wait until Deployed and Enabled=false
            for i in {1..90}; do
              sleep 10
              st=$(aws cloudfront get-distribution --id "$dist_id" --output json | jq -r '.Distribution.Status' || echo "Unknown")
              en=$(aws cloudfront get-distribution --id "$dist_id" --output json | jq -r '.Distribution.DistributionConfig.Enabled' || echo "Unknown")
              echo "Status: $st, Enabled: $en"
              if [ "$st" = "Deployed" ] && [ "$en" = "false" ]; then
                break
              fi
            done
          fi
          # Delete distribution
          etag=$(aws cloudfront get-distribution-config --id "$dist_id" --query 'ETag' --output text)
          echo "Deleting distribution $dist_id"
          aws cloudfront delete-distribution --id "$dist_id" --if-match "$etag" || true
          # Wait until deletion completes
          for i in {1..180}; do
            sleep 10
            if ! aws cloudfront get-distribution --id "$dist_id" >/dev/null 2>&1; then
              echo "Distribution $dist_id deleted."
              break
            else
              echo "Waiting for distribution deletion..."
            fi
          done

      - name: Terraform Destroy CloudFront/S3 module (wait for CF deletion)
        working-directory: infrastructure/environments/dev
        env:
          TF_VAR_mysql_password: "placeholder"
          TF_VAR_image_tag: "latest"
        run: terraform destroy -auto-approve -input=false -lock=false -lock-timeout=30m -target=module.s3_cloudfront

      - name: Pause briefly after CloudFront deletion
        run: sleep 20

      - name: Terraform Destroy RDS module
        working-directory: infrastructure/environments/dev
        env:
          TF_VAR_mysql_password: "placeholder"
          TF_VAR_image_tag: "latest"
        run: terraform destroy -auto-approve -input=false -lock=false -lock-timeout=10m -target=module.rds

      - name: Terraform Destroy ECR module
        working-directory: infrastructure/environments/dev
        env:
          TF_VAR_mysql_password: "placeholder"
          TF_VAR_image_tag: "latest"
        run: terraform destroy -auto-approve -input=false -lock=false -lock-timeout=10m -target=module.ecr

      - name: Terraform Destroy remaining resources (networking, security, etc.)
        working-directory: infrastructure/environments/dev
        env:
          TF_VAR_mysql_password: "placeholder"
          TF_VAR_image_tag: "latest"
        run: terraform destroy -auto-approve -input=false -lock=false -lock-timeout=15m

      - name: Destruction Summary
        run: |
          echo "## Dev Environment Destroyed ✅" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deleted Resources" >> $GITHUB_STEP_SUMMARY
          echo "- S3 bucket: \`${{ steps.tf_outputs.outputs.bucket }}\` (emptied, then removed by Terraform)" >> $GITHUB_STEP_SUMMARY
          echo "- ECR repos: \`${{ steps.ecr_names.outputs.backend_repo }}\`, \`${{ steps.ecr_names.outputs.frontend_repo }}\` (images purged, repos removed by Terraform)" >> $GITHUB_STEP_SUMMARY
          echo "- ECS, ALB, VPC, Subnets, Security Groups, RDS, CloudFront: removed by Terraform" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⏱️ Note: CloudFront distribution deletions can take several minutes to finalize." >> $GITHUB_STEP_SUMMARY


